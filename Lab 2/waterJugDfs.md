# Water Jug Problem Solver (DFS Approach)

## Problem Statement
Given two jugs with known capacities and a target amount of water, determine whether it is possible to measure exactly the target amount using only the following operations:
- Fill a jug completely.
- Empty a jug.
- Pour water from one jug to the other until one is empty or the other is full.

---
## Approach
- Use **Depth-First Search (DFS)** to explore all possible states of the two jugs.
- Represent each state as a pair `(amountInJug1, amountInJug2)`.
- From each state, generate all possible next states by:
  1. Filling either jug.
  2. Emptying either jug.
  3. Pouring water from one jug to the other.
- Keep track of visited states to avoid infinite loops.
- Stop when the target is found in either jug or in the total of both.

---
## Implementation Details
- `waterJugDFS`: Core DFS logic using a stack for state exploration and a set to track visited states.
- `nextStates`: Generated by performing all possible valid operations from the current state.
- Main function takes user input for jug capacities and target amount, then runs DFS.

---
## Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool solveWaterJugDFS(int jugACapacity, int jugBCapacity, int targetAmount) 
{
    stack<pair<int,int>> states;
    set<pair<int,int>> visitedStates;

    states.push({0,0});

    while(!states.empty()) 
    {
        auto [jugA, jugB] = states.top();
        states.pop();

        cout << "Current state: (" << jugA << ", " << jugB << ")\n";

        if (jugA == targetAmount || jugB == targetAmount || jugA + jugB == targetAmount) 
        {
            cout << "Reached target: (" << jugA << ", " << jugB << ")\n";
            return true;
        }

        if (visitedStates.count({jugA, jugB})) continue;
        visitedStates.insert({jugA, jugB});

        vector<pair<int,int>> nextMoves;

        // Fill either jug completely
        nextMoves.push_back({jugACapacity, jugB});
        nextMoves.push_back({jugA, jugBCapacity});

        // Empty either jug
        nextMoves.push_back({0, jugB});
        nextMoves.push_back({jugA, 0});

        // Pour from A to B
        int pourToB = min(jugA, jugBCapacity - jugB);
        nextMoves.push_back({jugA - pourToB, jugB + pourToB});

        // Pour from B to A
        int pourToA = min(jugB, jugACapacity - jugA);
        nextMoves.push_back({jugA + pourToA, jugB - pourToA});

        for (auto &move : nextMoves) 
        {
            if (!visitedStates.count(move))
                states.push(move);
        }
    }

    return false;
}

int main() 
{
    int jugA, jugB, target;
    cout << "Enter capacity of Jug A: "; cin >> jugA;
    cout << "Enter capacity of Jug B: "; cin >> jugB;
    cout << "Enter target amount: "; cin >> target;

    if (solveWaterJugDFS(jugA, jugB, target))
        cout << "Solution found!\n";
    else
        cout << "No solution possible!\n";

    return 0;
}


```
---

## Time Complexity
- Worst-case: **O(jug1Cap × jug2Cap)** (all possible states).
- DFS may explore deeply into one branch before backtracking.

## Space Complexity
- **O(jug1Cap × jug2Cap)** for storing visited states.

---
## Use Cases
- Classic AI search problem for understanding state-space exploration.
- Puzzle solving and algorithm learning.
- Foundation for more complex water distribution and resource allocation problems.

---
## Limitations
- DFS does not guarantee the shortest sequence of steps.
- Can explore unnecessary states before finding a solution.
- Limited to integer capacities and target amounts.
